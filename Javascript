1. call Method
The call method allows you to invoke a function and specify the this value and any arguments you want to pass to the function.

Syntax:
functionName.call(thisArg, arg1, arg2, ...);
thisArg refers to the object you want this to refer to in the function.
arg1, arg2, ... are the arguments you pass to the function.
Example:


let person = { firstname: "Akshay", lastname: "Saini" };

function greet(hometown, state) {
    console.log(this.firstname + " " + this.lastname + " from " + hometown + ", " + state);
}

greet.call(person, "Dehradun", "Uttarakhand");
// Output: Akshay Saini from Dehradun, Uttarakhand
Here, call allows greet to use person as its this context. This enables us to borrow the greet function for different objects.

2. apply Method
The apply method is similar to call, but it takes the arguments as an array instead of individual values.

Syntax:

functionName.apply(thisArg, [arg1, arg2, ...]);
thisArg is the object to use as this.
[arg1, arg2, ...] is an array of arguments passed to the function.
Example:


let person2 = { firstname: "Sachin", lastname: "Tendulkar" };

greet.apply(person2, ["Mumbai", "Maharashtra"]);
// Output: Sachin Tendulkar from Mumbai, Maharashtra
In this example, apply allows us to pass arguments as an array, which can be convenient when the arguments are already in an array format.

3. bind Method
The bind method doesnâ€™t immediately invoke the function. Instead, it creates a new function with the specified this value and arguments. You can then call this new function at a later time.

Syntax:

let newFunction = functionName.bind(thisArg, arg1, arg2, ...);
thisArg is the value of this inside the new function.
arg1, arg2, ... are optional arguments that will be preset in the new function.
Example:

let boundGreet = greet.bind(person2, "Mumbai", "Maharashtra");
boundGreet(); 
// Output: Sachin Tendulkar from Mumbai, Maharashtra

==========================================================================================================

SHORT OUTPUT BASED QS

1.console.log(!"hello");
In JavaScript, the ! (logical NOT) operator converts its operand to a boolean and then inverts it.

When you use ! with a string (like "hello"), JavaScript first converts the string to a boolean.
Any non-empty string (like "hello") is considered truthy, which means it evaluates to true when converted to a boolean.
Applying ! to true inverts it to false.
So:
console.log(!"hello"); // Output: false


2. console.log(+false);
In JavaScript, the + operator can be used to convert a boolean to a number.

false is converted to 0 when you apply the unary + operator, because false is considered falsy.
So, +false evaluates to 0.

Therefore:
console.log(+false); // Output: 0

3. arr=[1,2,3,4];
   arr.splice(0,1); //startindex, no_of_elements to be deleted
   arr.unshift(8); //[8,2,3,4];

4.Bitwise NOT Operator
console.log(~5); // Output: -6
Explanation: The ~ operator inverts the bits of the number. ~5 is equivalent to -(5 + 1), so the output is -6.

5.Nullish Coalescing Operator
let name = null;
console.log(name ?? "Default Name"); // Output: "Default Name"
Explanation: ?? returns the right side only if the left side is null or undefined.

---------shallow copy & deep copy-----------------------
6.// Example 1
let ritikRuns = { name: "Ritik", total: 0 };
let otherRuns = ritikRuns;
otherRuns.total = 90;

console.log(ritikRuns);
console.log(otherRuns);

{ name: "Ritik", total: 90 }
{ name: "Ritik", total: 90 }

explanation:In the first example, otherRuns is assigned the reference of ritikRuns. This means both ritikRuns and otherRuns point to the same object in memory. When otherRuns.total is updated to 90, it also updates ritikRuns.total because they reference the same object.



7. // Example 2
let ritikRuns = { name: "Ritik", total: 0 };
let otherRuns = { ...ritikRuns };  //or Object.assign({},ritikRuns);
otherRuns.total = 90;

console.log(ritikRuns);
console.log(otherRuns);

In the second example, otherRuns is created using the spread operator { ...ritikRuns }. This creates a shallow copy of ritikRuns, so otherRuns is a separate object. When otherRuns.total is updated to 90, it does not affect ritikRuns as they are now independent objects.

Output:
{ name: "Ritik", total: 0 }
{ name: "Ritik", total: 90 }

8. let ritikRuns = { name: "Ritik", total: 0 ,balls:{type:"leather"};
let otherRuns = { ...ritikRuns };  //or Object.assign({},ritikRuns);
otherRuns.total = 90;
otherRuns.balls.type="tennis";
console.log(ritikRuns);
console.log(otherRuns);

Output:
{ name: "Ritik", total: 0, balls:{type:"tennis"} }
{ name: "Ritik", total: 90,balls:{type:"tennis"} }

//Reason due to nested json ...spread operator does not create deep copy

so we do JSON.parse(JSON.stringify(developer));


IIFE (Immediately Invoked Function Expression)
=======================================================

var hello=function(){ //function expression
    console.log("hello world");
}

(function(){
    var prefix="HELLO";
    console.log("hello world");
})();

var prefix="HELLO BETU";
console.log(prefix);

//here there is no shadowing

to separate the variable from the global excution context.To stop polluting the global execution context.



=============================================================
